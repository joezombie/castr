@page "/feeds/new"
@page "/feeds/{Name}/edit"
@attribute [Authorize]
@inject IPodcastDataService DataService
@inject ILogger<FeedEdit> Logger
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IPlaylistWatcherTrigger PlaylistWatcherTrigger
@inject IYouTubeDownloadService YouTubeService
@using Castr.Data.Entities
@using Castr.Services

<PageTitle>@(_isNew ? "New Feed" : "Edit Feed") - Castr</PageTitle>

<MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-4">
    <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" OnClick="GoBack" />
    <MudText Typo="Typo.h3">@(_isNew ? "New Feed" : "Edit Feed")</MudText>
</MudStack>

@if (_loading)
{
    <MudProgressLinear Indeterminate="true" />
}
else
{
    <MudForm @ref="_form" @bind-IsValid="@_formValid">
        <MudGrid>
            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-4">Basic Information</MudText>

                    <MudTextField @bind-Value="_feed.Name" Label="Slug" Required="true" Disabled="@(!_isNew)"
                        HelperText="Unique identifier for URL (e.g., 'mypodcast')"
                        Validation="@(new Func<string, string?>(ValidateSlug))" />

                    <MudTextField @bind-Value="_feed.Title" Label="Title" Required="true" Class="mt-3"
                        HelperText="Display name for the podcast" />

                    <MudTextField @bind-Value="_feed.Description" Label="Description" Required="true" Class="mt-3"
                        Lines="3" />

                    <MudTextField @bind-Value="_feed.Directory" Label="Directory" Required="true" Class="mt-3"
                        HelperText="Path to media files (e.g., '/Podcasts/MyPodcast')" />

                    <MudNumericField @bind-Value="_feed.DirectorySearchDepth" Label="Subfolder Search Depth"
                        Class="mt-3" Min="0" Max="4"
                        HelperText="0 = root only, 1-4 = levels of subfolders to scan" />

                    @if (!_isNew)
                    {
                        <MudButton Variant="Variant.Outlined" Size="Size.Small" Class="mt-3"
                            OnClick="ForceResync" Disabled="_syncing"
                            StartIcon="@Icons.Material.Filled.Sync">
                            @if (_syncing)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Syncing...</span>
                            }
                            else
                            {
                                <span>Force Resync</span>
                            }
                        </MudButton>
                    }

                    <MudTextField @bind-Value="_feed.Author" Label="Author" Class="mt-3" />

                    <MudTextField @bind-Value="_feed.ImageUrl" Label="Image URL" Class="mt-3"
                        HelperText="Podcast cover art URL" />

                    <MudTextField @bind-Value="_feed.Link" Label="Website URL" Class="mt-3" />

                    <MudSelect @bind-Value="_feed.Language" Label="Language" Class="mt-3">
                        <MudSelectItem Value="@("en-us")">English (US)</MudSelectItem>
                        <MudSelectItem Value="@("en-gb")">English (UK)</MudSelectItem>
                        <MudSelectItem Value="@("es")">Spanish</MudSelectItem>
                        <MudSelectItem Value="@("fr")">French</MudSelectItem>
                        <MudSelectItem Value="@("de")">German</MudSelectItem>
                    </MudSelect>

                    <MudTextField @bind-Value="_feed.Category" Label="Category" Class="mt-3"
                        HelperText="iTunes category (e.g., 'Society & Culture')" />

                    <MudTextField @bind-Value="_fileExtensionsText" Label="File Extensions" Class="mt-3"
                        HelperText="Comma-separated (e.g., '.mp3,.m4a')" />

                    <MudNumericField @bind-Value="_feed.CacheDurationMinutes" Label="RSS Cache Duration (minutes)"
                        Class="mt-3" Min="1" Max="1440" />

                    <MudSwitch @bind-Value="_feed.IsActive" Label="Active" Color="Color.Primary" Class="mt-3" />
                </MudPaper>
            </MudItem>

            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-4">YouTube Configuration</MudText>

                    <MudSwitch @bind-Value="_feed.YouTubeEnabled" Label="Enable YouTube Monitoring" Color="Color.Primary" />

                    @if (_feed.YouTubeEnabled)
                    {
                        <MudTextField @bind-Value="_feed.YouTubePlaylistUrl" Label="Playlist URL" Class="mt-3"
                            HelperText="YouTube playlist URL or ID" />

                        @if (!string.IsNullOrWhiteSpace(_feed.YouTubePlaylistUrl))
                        {
                            <MudButton Variant="Variant.Outlined" Size="Size.Small" Class="mt-2"
                                OnClick="FetchYouTubeMetadata" Disabled="_fetchingMetadata"
                                StartIcon="@Icons.Material.Filled.Download">
                                @if (_fetchingMetadata)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                    <span>Fetching...</span>
                                }
                                else
                                {
                                    <span>Fetch Metadata</span>
                                }
                            </MudButton>
                        }

                        <MudNumericField @bind-Value="_feed.YouTubePollIntervalMinutes" Label="Poll Interval (minutes)"
                            Class="mt-3" Min="5" Max="1440" />

                        <MudNumericField @bind-Value="_feed.YouTubeMaxConcurrentDownloads" Label="Max Concurrent Downloads"
                            Class="mt-3" Min="1" Max="5" />

                        <MudSelect @bind-Value="_feed.YouTubeAudioQuality" Label="Audio Quality" Class="mt-3">
                            <MudSelectItem Value="@("highest")">Highest</MudSelectItem>
                            <MudSelectItem Value="@("medium")">Medium</MudSelectItem>
                            <MudSelectItem Value="@("lowest")">Lowest</MudSelectItem>
                        </MudSelect>
                    }
                </MudPaper>
            </MudItem>
        </MudGrid>

        <MudStack Row="true" Justify="Justify.FlexEnd" Class="mt-4">
            <MudButton Variant="Variant.Text" OnClick="GoBack">Cancel</MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveFeed" Disabled="@(!_formValid || _saving)">
                @if (_saving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                @(_isNew ? "Create Feed" : "Save Changes")
            </MudButton>
        </MudStack>
    </MudForm>
}

@code {
    [Parameter]
    public string? Name { get; set; }

    private Feed _feed = new()
    {
        Name = "",
        Title = "",
        Description = "",
        Directory = "",
        Language = "en-us",
        FileExtensions = [".mp3"],
        CacheDurationMinutes = 5,
        IsActive = true,
        YouTubeEnabled = false,
        YouTubePollIntervalMinutes = 60,
        YouTubeMaxConcurrentDownloads = 1,
        YouTubeAudioQuality = "highest"
    };

    private string _fileExtensionsText
    {
        get => string.Join(",", _feed.FileExtensions);
        set => _feed.FileExtensions = value.Split(',', StringSplitOptions.RemoveEmptyEntries)
            .Select(e => e.Trim()).ToArray();
    }

    private MudForm? _form;
    private bool _formValid;
    private bool _loading = true;
    private bool _saving;
    private bool _syncing;
    private bool _fetchingMetadata;
    private bool _isNew => string.IsNullOrEmpty(Name);

    protected override async Task OnInitializedAsync()
    {
        if (!_isNew)
        {
            await LoadFeedAsync();
        }
        else
        {
            _loading = false;
        }
    }

    private async Task LoadFeedAsync()
    {
        try
        {
            var feed = await DataService.GetFeedByNameAsync(Name!);
            if (feed == null)
            {
                Snackbar.Add("Feed not found", Severity.Error);
                Navigation.NavigateTo("/feeds");
                return;
            }
            _feed = feed;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load feed {Name}", Name);
            Snackbar.Add("Failed to load feed", Severity.Error);
            Navigation.NavigateTo("/feeds");
        }
        finally
        {
            _loading = false;
        }
    }

    private string? ValidateSlug(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return "Slug is required";
        if (!System.Text.RegularExpressions.Regex.IsMatch(value, @"^[a-z0-9-]+$"))
            return "Slug must contain only lowercase letters, numbers, and hyphens";
        return null;
    }

    private async Task SaveFeed()
    {
        if (_form == null) return;
        await _form.Validate();
        if (!_formValid) return;

        _saving = true;
        try
        {
            if (_isNew)
            {
                _feed.CreatedAt = DateTime.UtcNow;
                _feed.UpdatedAt = DateTime.UtcNow;
                var feedId = await DataService.AddFeedAsync(_feed);

                // Sync existing files in directory to database
                try
                {
                    await DataService.SyncDirectoryAsync(feedId, _feed.Directory, _feed.FileExtensions, _feed.DirectorySearchDepth);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to sync directory for new feed {FeedName}", _feed.Name);
                    Snackbar.Add("Feed created, but directory sync failed. Files will sync on next poll cycle.", Severity.Warning);
                }

                // Trigger immediate YouTube playlist processing if enabled
                if (_feed.YouTubeEnabled && !string.IsNullOrWhiteSpace(_feed.YouTubePlaylistUrl))
                {
                    PlaylistWatcherTrigger.TriggerFeedProcessing(_feed.Name);
                }

                Snackbar.Add("Feed created successfully", Severity.Success);
            }
            else
            {
                _feed.UpdatedAt = DateTime.UtcNow;
                await DataService.UpdateFeedAsync(_feed);
                Snackbar.Add("Feed updated successfully", Severity.Success);
            }
            Navigation.NavigateTo("/feeds");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save feed");
            Snackbar.Add("Failed to save feed", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private async Task FetchYouTubeMetadata()
    {
        if (string.IsNullOrWhiteSpace(_feed.YouTubePlaylistUrl)) return;

        _fetchingMetadata = true;
        StateHasChanged();
        try
        {
            var metadata = await YouTubeService.GetPlaylistMetadataAsync(_feed.YouTubePlaylistUrl);
            if (metadata == null)
            {
                Snackbar.Add("Failed to fetch playlist metadata. Check the URL and try again.", Severity.Error);
                return;
            }

            var populated = new List<string>();

            if (!string.IsNullOrWhiteSpace(metadata.Title) && string.IsNullOrWhiteSpace(_feed.Title))
            {
                _feed.Title = metadata.Title;
                populated.Add("Title");
            }
            if (!string.IsNullOrWhiteSpace(metadata.Author) && string.IsNullOrWhiteSpace(_feed.Author))
            {
                _feed.Author = metadata.Author;
                populated.Add("Author");
            }
            if (!string.IsNullOrWhiteSpace(metadata.ThumbnailUrl) && string.IsNullOrWhiteSpace(_feed.ImageUrl))
            {
                _feed.ImageUrl = metadata.ThumbnailUrl;
                populated.Add("Image URL");
            }
            if (!string.IsNullOrWhiteSpace(metadata.Description) && string.IsNullOrWhiteSpace(_feed.Description))
            {
                _feed.Description = metadata.Description;
                populated.Add("Description (from first video - review recommended)");
            }
            if (!string.IsNullOrWhiteSpace(metadata.PlaylistUrl) && string.IsNullOrWhiteSpace(_feed.Link))
            {
                _feed.Link = metadata.PlaylistUrl;
                populated.Add("Link");
            }

            if (populated.Count > 0)
                Snackbar.Add($"Populated: {string.Join(", ", populated)}", Severity.Success);
            else
                Snackbar.Add("All fields already have values. Clear fields you want to overwrite.", Severity.Info);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to fetch YouTube metadata for playlist: {PlaylistUrl}", _feed.YouTubePlaylistUrl);
            Snackbar.Add("Failed to fetch playlist metadata. Check the URL and try again.", Severity.Error);
        }
        finally
        {
            _fetchingMetadata = false;
        }
    }

    private async Task ForceResync()
    {
        if (_syncing) return;

        if (string.IsNullOrWhiteSpace(_feed.Directory))
        {
            Snackbar.Add("Cannot resync: no directory configured", Severity.Warning);
            return;
        }

        _syncing = true;
        StateHasChanged();
        try
        {
            if (!System.IO.Directory.Exists(_feed.Directory))
            {
                Snackbar.Add($"Directory not found: {_feed.Directory}", Severity.Error);
                return;
            }

            var newCount = await DataService.SyncDirectoryAsync(_feed.Id, _feed.Directory, _feed.FileExtensions, _feed.DirectorySearchDepth);
            if (newCount > 0)
                Snackbar.Add($"Directory resync completed: {newCount} new file(s) found", Severity.Success);
            else
                Snackbar.Add("Directory resync completed: no new files found", Severity.Info);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to resync directory for feed {FeedName}", _feed.Name);
            Snackbar.Add($"Directory resync failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _syncing = false;
        }
    }

    private void GoBack()
    {
        Navigation.NavigateTo("/feeds");
    }
}
